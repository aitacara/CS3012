<!DOCTYPE html>
<meta charset="utf-8">
<style>

body {
  font: 10px sans-serif;
}
.links line {
  stroke: #999;
  stroke-opacity: 0.6;
}

.nodes circle {
  stroke: #fff;
  stroke-width: 1.5px;
}

</style>
<body>
<svg width="2000" height="2000"></svg>
<script src="//d3js.org/d3.v4.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script>
// dataprocessing: Create graph json from github api data
var graph = '{"nodes":[], "links":[]}';
var obj = JSON.parse(graph);

d3.json("https://api.github.com/users/octocat", function(error, data) {
    console.log(data)
    var uname = data.uname;
    var img = data.avatar_url;
    var size = 80;
    obj['nodes'].push({uname,img,size});
});

var parent_index = 0
d3.json("https://api.github.com/users/octocat/followers", function(error, data) {
    var q = queue();
    
    for (var i=0; i<data.length; i++){
        var size = 50;
    	var filename = data[i].followers_url;
        var uname =data[i].login;
        var img = data[i].avatar_url
        var parent = obj['nodes'][0];
        var source = parent.login;
        var target = uname;
        obj['nodes'].push({uname,img,size});
        obj['links'].push({source,target});
        	console.log( filename)
        	q = q.defer(d3.json, filename);
        }
        q.await(onDataLoaded);
    });

    function onDataLoaded(error) {
        if (!error) {
            for (var i=1; i<arguments.length; i++){
                var children = arguments[i];
                indexOf(obj['nodes'], 1)
                for (var j=1; j<children.length; j++){
                    var size = 26
                    var uname = children[j].login;
                    var position = indexOf(obj['nodes'], uname);
                    var parentNode = obj['nodes'][i];
                    var source =parentNode.uname;
                    var target =uname;
                    if(position === -1){
                         var img = children[j].avatar_url
                         obj['nodes'].push({uname,img,size}); 
                         obj['links'].push({source,target});
                    }else{
                        obj['links'].push({source,target});

                    }
                } 
        }
        } else { console.log("load error") }

    jsonStr = JSON.stringify(obj);
    console.log(jsonStr)

    function indexOf(array, item) {
        for (var i = 1; i < array.length; i++) {
            if (array[i].uname === item){
                return i;
                }    
        }
        return -1;
    }

//Graph creation
var svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height");

var color = d3.scaleOrdinal(d3.schemeCategory20);

var simulation = d3.forceSimulation()
    .force("link", d3.forceLink().id(function(d) { return d.uname; }))
    .force("charge", d3.forceManyBody().strength(-150))
    .force("center", d3.forceCenter(width / 2, height / 2));

graph =JSON.parse(jsonStr);


  var link = svg.append("g")
      .attr("class", "links")
    .selectAll("line")
    .data(graph.links)
    .enter().append("line")
      .attr("stroke-width", function(d) { 1; });

  var nodes = svg.append("g")
      .attr("class", "nodes")
    .selectAll("circle")
    .data(graph.nodes)
    .enter().append("g").call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));;


    // Append images
  var node = nodes.append("svg:image")
        .attr("xlink:href",  function(d) { return d.img;})
        .attr("height", function(d) { return d.size;})
        .attr("width",function(d) { return d.size;});
 var empty = nodes.append("g");
 var selected = empty;
  var events = node.on( 'mouseenter', function() {
            // select element in current context
            selected =this;
            d3.select( this )
              .transition()
              //.attr("x", function(d) { return d.x - 25;})
              //.attr("y", function(d) { return d.y - 25;})
              .attr("height", 60)
              .attr("width", 60);
          })
          // set back
          .on( 'mouseleave', function() {
            d3.select( this )
              .transition()
              //.attr("x", function(d) { return d.x - 7.5;})
              //.attr("y", function(d) { return d.y - 7.5;})
              .attr("height", function(d) { return d.size;})
              .attr("width", function(d) { return d.size;});
          
          selected =empty;
          });


  node.append("title")
      .text(function(d) { return d.uname; });

  simulation
      .nodes(graph.nodes)
      .on("tick", ticked);

  simulation.force("link")
      .links(graph.links);

  function ticked() {
    link
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });

    node
        .attr("x", function(d) { return d.x - d.size/2; })
        .attr("y", function(d) { return d.y - d.size/2; });

  }

function dragstarted(d) {
  if (!d3.event.active) simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
}

function dragged(d) {
  d.fx = d3.event.x;
  d.fy = d3.event.y;
}

function dragended(d) {
  if (!d3.event.active) simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
}

}
</script>